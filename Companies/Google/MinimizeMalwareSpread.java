package Companies.Google;

import java.util.Arrays;

/**
 * First, let's color (the nodes of) each component of the graph. We can do this using DFS.
 * Afterwards, notice that if two nodes in initial have the same color (belong to the same component),
 * then removing them from initial won't decrease M(initial). This is because the malware will spread
 * to reach every node in this component no matter what.
 *
 * So, among nodes with a unique color in initial, we will remove the node with the largest component size.
 * (If there's a tie, we return the smallest index. Also, if there aren't any nodes with a unique color,
 * we'll just return the smallest index node.)
 *
 * Algorithm parts:
 * 1. Coloring each component: For each node, if it isn't yet colored, use DFS to traverse its component,
 * coloring that component with a new color.
 *
 * 2. Size of each color: Count the number of occurrences of each color.
 *
 * 3. Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.
 *
 * 4. Choose answer: For each node with a unique color, find the size of that color. The largest size is
 * selected, with ties broken by lowest node number. If there is no node with a unique color, the answer
 * is min(initial).
 *
 * Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
 * Space Complexity: O(N)
 */
public class MinimizeMalwareSpread {
    public int minMalwareSpread(int[][] g, int[] initial) {
        int[] colors = new int[g.length];
        Arrays.fill(colors, -1);
        int C = 0;
        // 1. Color each component. colors[node] = the color of this node.
        for (int i = 0; i < g.length; i++) {
            if (colors[i] == -1) {
                dfs(g, colors, i, C++);
            }
        }
        // 2. Size of each color.
        int[] size = new int[C];
        for (int color : colors) {
            size[color]++;
        }
        // 3. Find unique colors.
        int[] colorCount = new int[C];
        for (int node : initial) {
            colorCount[colors[node]]++;
        }
        int re = Integer.MAX_VALUE;
        for (int node : initial) {
            int color = colors[node];
            if (colorCount[color] == 1) {
                if (re == Integer.MAX_VALUE || size[color] > size[colors[re]]
                        || (size[color] == size[colors[re]] && node < re)) {
                    re = node;
                }
            }
        }
        if (re == Integer.MAX_VALUE) {
            for (int node : initial) {
                re = Math.min(re, node);
            }
        }
        return re;
    }

    private void dfs(int[][] g, int[] colors, int i, int color) {
        colors[i] = color;
        for (int neigh = 0; neigh < g.length; ++neigh) {
            if (g[i][neigh] == 1 && colors[neigh] == -1) {
                dfs(g, colors, neigh, color);
            }
        }
    }
}
